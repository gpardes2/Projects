#! /bin/bash

set -e

# Function to inject environment variables into a Spring Boot app
set_spring_app_env_vars() {
    local spring_app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local spring_service_name=$SPRING_APP_SERVICE_NAME
    local env_vars=("$@")

    logger "INFO" "Injecting environment variables into Spring Boot application $spring_app_name..."

    az spring app env var set --name "$spring_app_name" --resource-group "$resource_group" --service "$spring_service_name" "${env_vars[@]}"

    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to inject environment variables into Spring Boot application $spring_app_name"
        exit 1
    fi

    logger "INFO" "Successfully injected environment variables into Spring Boot application $spring_app_name."
}

# Main function to fetch DB2 certificates from Key Vault and provide them to the Spring web service app
fetch_and_provide_db2_certs() {
    local key_vault_name=$KEYVAULT_NAME
    local spring_app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local spring_service_name=$SPRING_APP_SERVICE_NAME
    local db2_client_cert_name=$DB2_CLIENT_CERT_NAME
    local db2_ca_cert_name=$DB2_CA_CERT_NAME

    # Fetch the DB2 client certificate and key
    local db2_client_cert=$(fetch_certificate_from_keyvault "$key_vault_name" "$db2_client_cert_name")
    local db2_client_key=$(fetch_secret_from_keyvault "$key_vault_name" "${db2_client_cert_name}-key")
    
    # Fetch the DB2 CA certificate
    local db2_ca_cert=$(fetch_certificate_from_keyvault "$key_vault_name" "$db2_ca_cert_name")

    # Injecting certificates into Spring Boot application as environment variables
    set_spring_app_env_vars "DB2_CLIENT_CERT=$db2_client_cert" "DB2_CLIENT_KEY=$db2_client_key" "DB2_CA_CERT=$db2_ca_cert"

}

# Function to fetch Oracle credentials from Key Vault and provide them to the Spring web service app
fetch_and_provide_oracle_creds() {
    local key_vault_name="$KEYVAULT_NAME"
    local oracle_secret_name="$ORACLE_SECRET_NAME"
    local spring_app_name="$SPRING_APP_NAME"
    local spring_service_name="$SPRING_APP_SERVICE_NAME"
    local resource_group="$RESOURCE_GROUP"
    
    logger "INFO" "Fetching Oracle credentials from Key Vault..."

    # Retrieve the Oracle credentials secret from Key Vault
    local oracle_creds
    oracle_creds=$(az keyvault secret show --vault-name "$key_vault_name" --name "$oracle_secret_name" --query "value" --output tsv)

    if [ $? -ne 0 ] || [ -z "$oracle_creds" ]; then
        logger "ERROR" "Failed to retrieve Oracle credentials from Key Vault $key_vault_name"
        exit 1
    fi

    # Parse the retrieved credentials
    local oracle_username oracle_password
    oracle_username=$(echo "$oracle_creds" | grep -oP '(?<=ORACLE_USERNAME=)[^\n]+')
    oracle_password=$(echo "$oracle_creds" | grep -oP '(?<=ORACLE_PASSWORD=)[^\n]+')

    if [ -z "$oracle_username" ] || [ -z "$oracle_password" ]; then
        logger "ERROR" "Failed to parse Oracle credentials from the secret"
        exit 1
    fi

    # Inject the Oracle credentials into the Spring Boot application as environment variables
    set_spring_app_env_vars "ORACLE_USERNAME=$oracle_username" "ORACLE_PASSWORD=$oracle_password"
    
    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to set environment variables for the Spring Boot app"
        exit 1
    fi

    logger "INFO" "Oracle credentials successfully provided to the Spring Boot app"
}

# Function for scaling webservice
scale_spring_app() {
    logger "INFO" "Scaling Spring Boot Application..."
    local scale_command="az spring app scale --name $SPRING_APP_NAME --resource-group $SPRING_APP_RESOURCE_GROUP --service $SPRING_APP_SERVICE"

    # Append options if they are set
    [ -n "$SPRING_APP_CPU" ] && scale_command+=" --cpu $SPRING_APP_CPU"
    [ -n "$SPRING_APP_INSTANCE_COUNT" ] && scale_command+=" --instance-count $SPRING_APP_INSTANCE_COUNT"
    [ -n "$SPRING_APP_MAX_REPLICAS" ] && scale_command+=" --max-replicas $SPRING_APP_MAX_REPLICAS"
    [ -n "$SPRING_APP_MEMORY" ] && scale_command+=" --memory $SPRING_APP_MEMORY"
    [ -n "$SPRING_APP_MIN_REPLICAS" ] && scale_command+=" --min-replicas $SPRING_APP_MIN_REPLICAS"
    [ -n "$SPRING_APP_SCALE_RULE_NAME" ] && scale_command+=" --scale-rule-name $SPRING_APP_SCALE_RULE_NAME"
    [ -n "$SPRING_APP_SCALE_RULE_HTTP_CONCURRENCY" ] && scale_command+=" --scale-rule-http-concurrency $SPRING_APP_SCALE_RULE_HTTP_CONCURRENCY"
    [ -n "$SPRING_APP_SCALE_RULE_TYPE" ] && scale_command+=" --scale-rule-type $SPRING_APP_SCALE_RULE_TYPE"
    [ -n "$SPRING_APP_DEPLOYMENT_NAME" ] && scale_command+=" --deployment $SPRING_APP_DEPLOYMENT_NAME"

    # Execute the scale command and check for success
    if eval "$scale_command"; then
        logger "INFO" "Successfully scaled Spring Boot app: $SPRING_APP_NAME"
    else
        logger "ERROR" "Failed to scale Spring Boot app: $SPRING_APP_NAME" >&2
        exit 1
    fi
}

# Function to create or update a deployment in Azure Spring App
create_spring_app_deployment() {
    local resource_group=$RESOURCE_GROUP
    local spring_service_name=$SPRING_APP_SERVICE_NAME
    local spring_app_name=$SPRING_APP_NAME
    local deployment_name=$1
    local runtime_version=$SPRING_APP_RUNTIME_VERSION
    local cpu=$SPRING_APP_CPU
    local memory=$SPRING_APP_MEMORY
    local instance_count=$SPRING_APP_INSTANCE_COUNT

    logger "INFO" "Creating deployment: $deployment_name for Spring App: $spring_app_name in Resource Group: $resource_group..."

    az spring app deployment create \
        --resource-group "$resource_group" \
        --service "$spring_service_name" \
        --app "$spring_app_name" \
        --name "$deployment_name" \
        --artifact-path "$jar_file_url" \
        --cpu "$cpu" \
        --memory "$memory" \
        --instance-count "$instance_count" \
        --runtime-version "$runtime_version"

    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to create deployment: $deployment_name for Spring App: $spring_app_name"
        return 1
    fi

    logger "INFO" "Deployment $deployment_name created successfully for Spring App: $spring_app_name."
    return 0
}


# Function to switch webservice between green-blue deployment
switch_webservice_deployment() {
    local deployment_name=$SPRING_APP_DEPLOYMENT_NAME
    local app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local service_name=$SPRING_APP_SERVICE

    # Build the command for setting the deployment
    local set_deployment_command="az spring app set-deployment --deployment $deployment_name --name $app_name --resource-group $resource_group --service $service_name"

    # Append --no-wait if the NO_WAIT flag is set
    [ "$SPRING_APP_NO_WAIT" = "true" ] && set_deployment_command+=" --no-wait"

    # Execute the command and check for success
    if eval "$set_deployment_command"; then
        logger "INFO" "Successfully switched to deployment: $deployment_name for app: $app_name"
    else
        logger "ERROR" "Failed to switch deployment to: $deployment_name for app: $app_name" >&2
        exit 1
    fi
}

start_webservice() {
    local app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local service_name=$SPRING_APP_SERVICE

    # Build the start command
    local start_command="az spring app start --name $app_name --resource-group $resource_group --service $service_name"

    # Append --deployment if specified
    [ -n "$SPRING_APP_DEPLOYMENT_NAME" ] && start_command+=" --deployment $SPRING_APP_DEPLOYMENT_NAME"

    # Append --no-wait if the NO_WAIT flag is set
    [ "$SPRING_APP_NO_WAIT" = "true" ] && start_command+=" --no-wait"

    # Execute the command and check for success
    if eval "$start_command"; then
        logger "INFO" "Successfully started Spring Boot app: $app_name"
    else
        logger "ERROR" "Failed to start Spring Boot app: $app_name" >&2
        exit 1
    fi
}

stop_webservice() {
    local app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local service_name=$SPRING_APP_SERVICE

    # Build the stop command
    local stop_command="az spring app stop --name $app_name --resource-group $resource_group --service $service_name"

    # Append --deployment if specified
    [ -n "$SPRING_APP_DEPLOYMENT_NAME" ] && stop_command+=" --deployment $SPRING_APP_DEPLOYMENT_NAME"

    # Append --no-wait if the NO_WAIT flag is set
    [ "$SPRING_APP_NO_WAIT" = "true" ] && stop_command+=" --no-wait"

    # Execute the command and check for success
    if eval "$stop_command"; then
        logger "INFO" "Successfully stopped Spring Boot app: $app_name"
    else
        logger "ERROR" "Failed to stop Spring Boot app: $app_name" >&2
        exit 1
    fi
}

# Function to restart an Azure Spring App
restart_spring_app() {
    local resource_group=$RESOURCE_GROUP
    local spring_service_name=$SPRING_APP_SERVICE_NAME
    local spring_app_name=$SPRING_APP_NAME
    local deployment_name=$SPRING_APP_DEPLOYMENT_NAME
    local no_wait=$SPRING_APP_NO_WAIT

    logger "INFO" "Restarting Spring App: $spring_app_name in Resource Group: $resource_group..."

    if [ -z "$deployment_name" ]; then
        az spring app restart \
            --name "$spring_app_name" \
            --resource-group "$resource_group" \
            --service "$spring_service_name" \
            --no-wait "$no_wait"
    else
        az spring app restart \
            --name "$spring_app_name" \
            --resource-group "$resource_group" \
            --service "$spring_service_name" \
            --deployment "$deployment_name" \
            --no-wait "$no_wait"
    fi

    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to restart Spring App: $spring_app_name"
        return 1
    fi

    logger "INFO" "Spring App $spring_app_name restarted successfully."
    return 0
}

unset_webservice_deployment() {
    local app_name=$SPRING_APP_NAME
    local resource_group=$RESOURCE_GROUP
    local service_name=$SPRING_APP_SERVICE

    # Build the unset-deployment command
    local unset_deployment_command="az spring app unset-deployment --name $app_name --resource-group $resource_group --service $service_name"

    # Append --no-wait if the NO_WAIT flag is set
    [ "$SPRING_APP_NO_WAIT" = "true" ] && unset_deployment_command+=" --no-wait"

    # Execute the command and check for success
    if eval "$unset_deployment_command"; then
        logger "INFO" "Successfully unset the deployment for Spring Boot app: $app_name"
    else
        logger "ERROR" "Failed to unset the deployment for Spring Boot app: $app_name" >&2
        exit 1
    fi
}

# Add Persistent storage account in spring app
add_storage_to_spring_app() {
    local resource_group=$RESOURCE_GROUP
    local spring_service_name=$SPRING_APP_SERVICE_NAME
    local spring_app_name=$SPRING_APP_tNAME
    local storage_account_name=$STORAGE_ACCOUNT
    local key_vault_name=$KEYVAULT_NAME

    # Fetch storage account name and key from Key Vault
    logger "INFO" "Retrieving storage account credentials from Key Vault: $key_vault_name"

    local account_key=$(az keyvault secret show --vault-name $key_vault_name \
                                               --name "${storage_account_name}-account-key" \
                                               --query value --output tsv)

    if [ -z "$storage_account_name" ] || [ -z "$account_key" ]; then
        logger "ERROR" "Failed to retrieve storage account credentials from Key Vault" >&2
        exit 1
    fi

    # Add storage account to Spring App
    logger "INFO" "Adding storage account $storage_account_name to Spring App $spring_app_name"
    az spring app storage add --resource-group $resource_group \
                              --service $spring_service_name \
                              --name $spring_app_name \
                              --storage-type StorageAccount \
                              --account-name $storage_account_name \
                              --account-key $account_key

    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to add storage account $storage_account_name to Spring App $spring_app_name" >&2
        exit 1
    fi

    logger "INFO" "Storage account $storage_account_name added to Spring App $spring_app_name successfully."
}

# Function to update a Spring Boot app with environment variables
update_spring_app() {
    local app_name="${SPRING_APP_NAME}"
    local resource_group="${RESOURCE_GROUP}"
    local service_name="${SPRING_APP_SERVICE_NAME}"

    logger "INFO" "Updating Spring Boot application: $app_name"

    # Build the az command with parameters from environment variables
    local az_command="az spring app update --name \"$app_name\" --resource-group \"$resource_group\" --service \"$service_name\""

    # Append optional parameters if they are set
    [ -n "$SPRING_APP_ASSIGN_ENDPOINT" ] && az_command+=" --assign-endpoint $SPRING_APP_ASSIGN_ENDPOINT"
    [ -n "$SPRING_APP_ASSIGN_PUBLIC_ENDPOINT" ] && az_command+=" --assign-public-endpoint $SPRING_APP_ASSIGN_PUBLIC_ENDPOINT"
    [ -n "$SPRING_APP_BACKEND_PROTOCOL" ] && az_command+=" --backend-protocol $SPRING_APP_BACKEND_PROTOCOL"
    [ -n "$SPRING_APP_CLIENT_AUTH_CERTS" ] && az_command+=" --client-auth-certs $SPRING_APP_CLIENT_AUTH_CERTS"
    [ -n "$SPRING_APP_CONFIG_FILE_PATTERNS" ] && az_command+=" --config-file-patterns $SPRING_APP_CONFIG_FILE_PATTERNS"
    [ -n "$SPRING_APP_CUSTOM_ACTUATOR_PATH" ] && az_command+=" --custom-actuator-path $SPRING_APP_CUSTOM_ACTUATOR_PATH"
    [ -n "$SPRING_APP_CUSTOM_ACTUATOR_PORT" ] && az_command+=" --custom-actuator-port $SPRING_APP_CUSTOM_ACTUATOR_PORT"
    [ -n "$SPRING_APP_DEPLOYMENT" ] && az_command+=" --deployment $SPRING_APP_DEPLOYMENT"
    [ -n "$SPRING_APP_DISABLE_PROBE" ] && az_command+=" --disable-probe $SPRING_APP_DISABLE_PROBE"
    [ -n "$SPRING_APP_DISABLE_TEA" ] && az_command+=" --disable-tea $SPRING_APP_DISABLE_TEA"
    [ -n "$SPRING_APP_ENABLE_INGRESS_TO_APP_TLS" ] && az_command+=" --enable-ingress-to-app-tls $SPRING_APP_ENABLE_INGRESS_TO_APP_TLS"
    [ -n "$SPRING_APP_ENABLE_LIVENESS_PROBE" ] && az_command+=" --enable-liveness-probe $SPRING_APP_ENABLE_LIVENESS_PROBE"
    [ -n "$SPRING_APP_ENABLE_PERSISTENT_STORAGE" ] && az_command+=" --enable-persistent-storage $SPRING_APP_ENABLE_PERSISTENT_STORAGE"
    [ -n "$SPRING_APP_ENABLE_READINESS_PROBE" ] && az_command+=" --enable-readiness-probe $SPRING_APP_ENABLE_READINESS_PROBE"
    [ -n "$SPRING_APP_ENABLE_STARTUP_PROBE" ] && az_command+=" --enable-startup-probe $SPRING_APP_ENABLE_STARTUP_PROBE"
    [ -n "$SPRING_APP_ENV" ] && az_command+=" --env $SPRING_APP_ENV"
    [ -n "$SPRING_APP_GRACE_PERIOD" ] && az_command+=" --grace-period $SPRING_APP_GRACE_PERIOD"
    [ -n "$SPRING_APP_HTTPS_ONLY" ] && az_command+=" --https-only $SPRING_APP_HTTPS_ONLY"
    [ -n "$SPRING_APP_INGRESS_READ_TIMEOUT" ] && az_command+=" --ingress-read-timeout $SPRING_APP_INGRESS_READ_TIMEOUT"
    [ -n "$SPRING_APP_INGRESS_SEND_TIMEOUT" ] && az_command+=" --ingress-send-timeout $SPRING_APP_INGRESS_SEND_TIMEOUT"
    [ -n "$SPRING_APP_JVM_OPTIONS" ] && az_command+=" --jvm-options $SPRING_APP_JVM_OPTIONS"
    [ -n "$SPRING_APP_LIVENESS_PROBE_CONFIG" ] && az_command+=" --liveness-probe-config $SPRING_APP_LIVENESS_PROBE_CONFIG"
    [ -n "$SPRING_APP_LOADED_PUBLIC_CERTIFICATE_FILE" ] && az_command+=" --loaded-public-certificate-file $SPRING_APP_LOADED_PUBLIC_CERTIFICATE_FILE"
    [ -n "$SPRING_APP_MAIN_ENTRY" ] && az_command+=" --main-entry $SPRING_APP_MAIN_ENTRY"
    [ -n "$SPRING_APP_NO_WAIT" ] && az_command+=" --no-wait $SPRING_APP_NO_WAIT"
    [ -n "$SPRING_APP_PERSISTENT_STORAGE" ] && az_command+=" --persistent-storage $SPRING_APP_PERSISTENT_STORAGE"
    [ -n "$SPRING_APP_READINESS_PROBE_CONFIG" ] && az_command+=" --readiness-probe-config $SPRING_APP_READINESS_PROBE_CONFIG"
    [ -n "$SPRING_APP_RUNTIME_VERSION" ] && az_command+=" --runtime-version $SPRING_APP_RUNTIME_VERSION"
    [ -n "$SPRING_APP_SECRETS" ] && az_command+=" --secrets $SPRING_APP_SECRETS"
    [ -n "$SPRING_APP_SESSION_AFFINITY" ] && az_command+=" --session-affinity $SPRING_APP_SESSION_AFFINITY"
    [ -n "$SPRING_APP_SESSION_MAX_AGE" ] && az_command+=" --session-max-age $SPRING_APP_SESSION_MAX_AGE"
    [ -n "$SPRING_APP_STARTUP_PROBE_CONFIG" ] && az_command+=" --startup-probe-config $SPRING_APP_STARTUP_PROBE_CONFIG"
    [ -n "$SPRING_APP_WORKLOAD_PROFILE" ] && az_command+=" --workload-profile $SPRING_APP_WORKLOAD_PROFILE"

    # Execute the command
    logger "INFO" "Executing command: $az_command"
    eval $az_command

    if [ $? -ne 0 ]; then
        logger "ERROR" "Failed to update Spring Boot application: $app_name"
        exit 1
    fi

    logger "INFO" "Successfully updated Spring Boot application: $app_name"
}

